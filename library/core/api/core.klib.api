// Klib ABI Dump
// Targets: [androidNativeArm32, androidNativeArm64, androidNativeX64, androidNativeX86, iosArm64, iosSimulatorArm64, iosX64, js, linuxArm64, linuxX64, macosArm64, macosX64, mingwX64, tvosArm64, tvosSimulatorArm64, tvosX64, wasmJs, wasmWasi, watchosArm32, watchosArm64, watchosDeviceArm64, watchosSimulatorArm64, watchosX64]
// Rendering settings:
// - Signature version: 2
// - Show manifest properties: true
// - Show declarations: true

// Library unique name: <io.matthewnelson.encoding:core>
open annotation class io.matthewnelson.encoding.core.internal/InternalEncodingApi : kotlin/Annotation { // io.matthewnelson.encoding.core.internal/InternalEncodingApi|null[0]
    constructor <init>() // io.matthewnelson.encoding.core.internal/InternalEncodingApi.<init>|<init>(){}[0]
}

open annotation class io.matthewnelson.encoding.core/ExperimentalEncodingApi : kotlin/Annotation { // io.matthewnelson.encoding.core/ExperimentalEncodingApi|null[0]
    constructor <init>() // io.matthewnelson.encoding.core/ExperimentalEncodingApi.<init>|<init>(){}[0]
}

abstract class <#A: io.matthewnelson.encoding.core/EncoderDecoder.Config> io.matthewnelson.encoding.core/EncoderDecoder : io.matthewnelson.encoding.core/Encoder<#A> { // io.matthewnelson.encoding.core/EncoderDecoder|null[0]
    constructor <init>(#A) // io.matthewnelson.encoding.core/EncoderDecoder.<init>|<init>(1:0){}[0]

    abstract fun name(): kotlin/String // io.matthewnelson.encoding.core/EncoderDecoder.name|name(){}[0]
    final fun equals(kotlin/Any?): kotlin/Boolean // io.matthewnelson.encoding.core/EncoderDecoder.equals|equals(kotlin.Any?){}[0]
    final fun hashCode(): kotlin/Int // io.matthewnelson.encoding.core/EncoderDecoder.hashCode|hashCode(){}[0]
    final fun toString(): kotlin/String // io.matthewnelson.encoding.core/EncoderDecoder.toString|toString(){}[0]

    abstract class Config { // io.matthewnelson.encoding.core/EncoderDecoder.Config|null[0]
        constructor <init>(kotlin/Boolean?, kotlin/Byte, kotlin/Char?) // io.matthewnelson.encoding.core/EncoderDecoder.Config.<init>|<init>(kotlin.Boolean?;kotlin.Byte;kotlin.Char?){}[0]

        final val isLenient // io.matthewnelson.encoding.core/EncoderDecoder.Config.isLenient|{}isLenient[0]
            final fun <get-isLenient>(): kotlin/Boolean? // io.matthewnelson.encoding.core/EncoderDecoder.Config.isLenient.<get-isLenient>|<get-isLenient>(){}[0]
        final val lineBreakInterval // io.matthewnelson.encoding.core/EncoderDecoder.Config.lineBreakInterval|{}lineBreakInterval[0]
            final fun <get-lineBreakInterval>(): kotlin/Byte // io.matthewnelson.encoding.core/EncoderDecoder.Config.lineBreakInterval.<get-lineBreakInterval>|<get-lineBreakInterval>(){}[0]
        final val paddingChar // io.matthewnelson.encoding.core/EncoderDecoder.Config.paddingChar|{}paddingChar[0]
            final fun <get-paddingChar>(): kotlin/Char? // io.matthewnelson.encoding.core/EncoderDecoder.Config.paddingChar.<get-paddingChar>|<get-paddingChar>(){}[0]

        abstract fun decodeOutMaxSizeOrFailProtected(kotlin/Int, io.matthewnelson.encoding.core.util/DecoderInput): kotlin/Int // io.matthewnelson.encoding.core/EncoderDecoder.Config.decodeOutMaxSizeOrFailProtected|decodeOutMaxSizeOrFailProtected(kotlin.Int;io.matthewnelson.encoding.core.util.DecoderInput){}[0]
        abstract fun decodeOutMaxSizeProtected(kotlin/Long): kotlin/Long // io.matthewnelson.encoding.core/EncoderDecoder.Config.decodeOutMaxSizeProtected|decodeOutMaxSizeProtected(kotlin.Long){}[0]
        abstract fun encodeOutSizeProtected(kotlin/Long): kotlin/Long // io.matthewnelson.encoding.core/EncoderDecoder.Config.encodeOutSizeProtected|encodeOutSizeProtected(kotlin.Long){}[0]
        abstract fun toStringAddSettings(): kotlin.collections/Set<io.matthewnelson.encoding.core/EncoderDecoder.Config.Setting> // io.matthewnelson.encoding.core/EncoderDecoder.Config.toStringAddSettings|toStringAddSettings(){}[0]
        final fun decodeOutMaxSize(kotlin/Long): kotlin/Long // io.matthewnelson.encoding.core/EncoderDecoder.Config.decodeOutMaxSize|decodeOutMaxSize(kotlin.Long){}[0]
        final fun decodeOutMaxSizeOrFail(io.matthewnelson.encoding.core.util/DecoderInput): kotlin/Int // io.matthewnelson.encoding.core/EncoderDecoder.Config.decodeOutMaxSizeOrFail|decodeOutMaxSizeOrFail(io.matthewnelson.encoding.core.util.DecoderInput){}[0]
        final fun encodeOutSize(kotlin/Long): kotlin/Long // io.matthewnelson.encoding.core/EncoderDecoder.Config.encodeOutSize|encodeOutSize(kotlin.Long){}[0]
        final fun encodeOutSize(kotlin/Long, kotlin/Byte): kotlin/Long // io.matthewnelson.encoding.core/EncoderDecoder.Config.encodeOutSize|encodeOutSize(kotlin.Long;kotlin.Byte){}[0]
        final fun equals(kotlin/Any?): kotlin/Boolean // io.matthewnelson.encoding.core/EncoderDecoder.Config.equals|equals(kotlin.Any?){}[0]
        final fun hashCode(): kotlin/Int // io.matthewnelson.encoding.core/EncoderDecoder.Config.hashCode|hashCode(){}[0]
        final fun toString(): kotlin/String // io.matthewnelson.encoding.core/EncoderDecoder.Config.toString|toString(){}[0]

        final inner class Setting { // io.matthewnelson.encoding.core/EncoderDecoder.Config.Setting|null[0]
            constructor <init>(kotlin/String, kotlin/Any?) // io.matthewnelson.encoding.core/EncoderDecoder.Config.Setting.<init>|<init>(kotlin.String;kotlin.Any?){}[0]

            final val name // io.matthewnelson.encoding.core/EncoderDecoder.Config.Setting.name|{}name[0]
                final fun <get-name>(): kotlin/String // io.matthewnelson.encoding.core/EncoderDecoder.Config.Setting.name.<get-name>|<get-name>(){}[0]
            final val value // io.matthewnelson.encoding.core/EncoderDecoder.Config.Setting.value|{}value[0]
                final fun <get-value>(): kotlin/Any? // io.matthewnelson.encoding.core/EncoderDecoder.Config.Setting.value.<get-value>|<get-value>(){}[0]

            final fun equals(kotlin/Any?): kotlin/Boolean // io.matthewnelson.encoding.core/EncoderDecoder.Config.Setting.equals|equals(kotlin.Any?){}[0]
            final fun hashCode(): kotlin/Int // io.matthewnelson.encoding.core/EncoderDecoder.Config.Setting.hashCode|hashCode(){}[0]
            final fun toString(): kotlin/String // io.matthewnelson.encoding.core/EncoderDecoder.Config.Setting.toString|toString(){}[0]
        }

        final object Companion { // io.matthewnelson.encoding.core/EncoderDecoder.Config.Companion|null[0]
            final fun outSizeExceedsMaxEncodingSizeException(kotlin/Number, kotlin/Number): io.matthewnelson.encoding.core/EncodingSizeException // io.matthewnelson.encoding.core/EncoderDecoder.Config.Companion.outSizeExceedsMaxEncodingSizeException|outSizeExceedsMaxEncodingSizeException(kotlin.Number;kotlin.Number){}[0]
        }
    }

    sealed class <#A1: io.matthewnelson.encoding.core/EncoderDecoder.Config> Feed { // io.matthewnelson.encoding.core/EncoderDecoder.Feed|null[0]
        constructor <init>(#A1) // io.matthewnelson.encoding.core/EncoderDecoder.Feed.<init>|<init>(1:0){}[0]

        final val config // io.matthewnelson.encoding.core/EncoderDecoder.Feed.config|{}config[0]
            final fun <get-config>(): #A1 // io.matthewnelson.encoding.core/EncoderDecoder.Feed.config.<get-config>|<get-config>(){}[0]

        abstract fun close() // io.matthewnelson.encoding.core/EncoderDecoder.Feed.close|close(){}[0]
        abstract fun doFinalProtected() // io.matthewnelson.encoding.core/EncoderDecoder.Feed.doFinalProtected|doFinalProtected(){}[0]
        abstract fun flush() // io.matthewnelson.encoding.core/EncoderDecoder.Feed.flush|flush(){}[0]
        abstract fun isClosed(): kotlin/Boolean // io.matthewnelson.encoding.core/EncoderDecoder.Feed.isClosed|isClosed(){}[0]
        final fun doFinal() // io.matthewnelson.encoding.core/EncoderDecoder.Feed.doFinal|doFinal(){}[0]
    }
}

abstract class io.matthewnelson.encoding.core.util/FeedBuffer { // io.matthewnelson.encoding.core.util/FeedBuffer|null[0]
    constructor <init>(kotlin/Int, io.matthewnelson.encoding.core.util/FeedBuffer.Flush, io.matthewnelson.encoding.core.util/FeedBuffer.Finalize) // io.matthewnelson.encoding.core.util/FeedBuffer.<init>|<init>(kotlin.Int;io.matthewnelson.encoding.core.util.FeedBuffer.Flush;io.matthewnelson.encoding.core.util.FeedBuffer.Finalize){}[0]

    final val blockSize // io.matthewnelson.encoding.core.util/FeedBuffer.blockSize|{}blockSize[0]
        final fun <get-blockSize>(): kotlin/Int // io.matthewnelson.encoding.core.util/FeedBuffer.blockSize.<get-blockSize>|<get-blockSize>(){}[0]

    final var count // io.matthewnelson.encoding.core.util/FeedBuffer.count|{}count[0]
        final fun <get-count>(): kotlin/Int // io.matthewnelson.encoding.core.util/FeedBuffer.count.<get-count>|<get-count>(){}[0]

    final fun finalize() // io.matthewnelson.encoding.core.util/FeedBuffer.finalize|finalize(){}[0]
    final fun update(kotlin/Int) // io.matthewnelson.encoding.core.util/FeedBuffer.update|update(kotlin.Int){}[0]

    abstract fun interface Finalize { // io.matthewnelson.encoding.core.util/FeedBuffer.Finalize|null[0]
        abstract fun invoke(kotlin/Int, kotlin/IntArray) // io.matthewnelson.encoding.core.util/FeedBuffer.Finalize.invoke|invoke(kotlin.Int;kotlin.IntArray){}[0]
    }

    abstract fun interface Flush { // io.matthewnelson.encoding.core.util/FeedBuffer.Flush|null[0]
        abstract fun invoke(kotlin/IntArray) // io.matthewnelson.encoding.core.util/FeedBuffer.Flush.invoke|invoke(kotlin.IntArray){}[0]
    }

    final object Companion { // io.matthewnelson.encoding.core.util/FeedBuffer.Companion|null[0]
        final fun truncatedInputEncodingException(kotlin/Int): io.matthewnelson.encoding.core/EncodingException // io.matthewnelson.encoding.core.util/FeedBuffer.Companion.truncatedInputEncodingException|truncatedInputEncodingException(kotlin.Int){}[0]
    }
}

final class io.matthewnelson.encoding.core.util/CTCase { // io.matthewnelson.encoding.core.util/CTCase|null[0]
    constructor <init>(kotlin/CharSequence) // io.matthewnelson.encoding.core.util/CTCase.<init>|<init>(kotlin.CharSequence){}[0]

    final val lowers // io.matthewnelson.encoding.core.util/CTCase.lowers|{}lowers[0]
        final fun <get-lowers>(): kotlin.collections/Set<kotlin/Char> // io.matthewnelson.encoding.core.util/CTCase.lowers.<get-lowers>|<get-lowers>(){}[0]
    final val uppers // io.matthewnelson.encoding.core.util/CTCase.uppers|{}uppers[0]
        final fun <get-uppers>(): kotlin.collections/Set<kotlin/Char> // io.matthewnelson.encoding.core.util/CTCase.uppers.<get-uppers>|<get-uppers>(){}[0]

    final fun lowercase(kotlin/Char): kotlin/Char? // io.matthewnelson.encoding.core.util/CTCase.lowercase|lowercase(kotlin.Char){}[0]
    final fun uppercase(kotlin/Char): kotlin/Char? // io.matthewnelson.encoding.core.util/CTCase.uppercase|uppercase(kotlin.Char){}[0]
}

final class io.matthewnelson.encoding.core.util/DecoderInput { // io.matthewnelson.encoding.core.util/DecoderInput|null[0]
    constructor <init>(kotlin/ByteArray) // io.matthewnelson.encoding.core.util/DecoderInput.<init>|<init>(kotlin.ByteArray){}[0]
    constructor <init>(kotlin/CharArray) // io.matthewnelson.encoding.core.util/DecoderInput.<init>|<init>(kotlin.CharArray){}[0]
    constructor <init>(kotlin/CharSequence) // io.matthewnelson.encoding.core.util/DecoderInput.<init>|<init>(kotlin.CharSequence){}[0]

    final fun get(kotlin/Int): kotlin/Char // io.matthewnelson.encoding.core.util/DecoderInput.get|get(kotlin.Int){}[0]
}

final class io.matthewnelson.encoding.core.util/LineBreakOutFeed : io.matthewnelson.encoding.core/Encoder.OutFeed { // io.matthewnelson.encoding.core.util/LineBreakOutFeed|null[0]
    constructor <init>(kotlin/Byte, io.matthewnelson.encoding.core/Encoder.OutFeed) // io.matthewnelson.encoding.core.util/LineBreakOutFeed.<init>|<init>(kotlin.Byte;io.matthewnelson.encoding.core.Encoder.OutFeed){}[0]

    final val interval // io.matthewnelson.encoding.core.util/LineBreakOutFeed.interval|{}interval[0]
        final fun <get-interval>(): kotlin/Byte // io.matthewnelson.encoding.core.util/LineBreakOutFeed.interval.<get-interval>|<get-interval>(){}[0]

    final fun output(kotlin/Char) // io.matthewnelson.encoding.core.util/LineBreakOutFeed.output|output(kotlin.Char){}[0]
    final fun reset() // io.matthewnelson.encoding.core.util/LineBreakOutFeed.reset|reset(){}[0]
}

open class io.matthewnelson.encoding.core/EncodingException : kotlin/RuntimeException { // io.matthewnelson.encoding.core/EncodingException|null[0]
    constructor <init>(kotlin/String) // io.matthewnelson.encoding.core/EncodingException.<init>|<init>(kotlin.String){}[0]
    constructor <init>(kotlin/String, kotlin/Throwable?) // io.matthewnelson.encoding.core/EncodingException.<init>|<init>(kotlin.String;kotlin.Throwable?){}[0]

    final val message // io.matthewnelson.encoding.core/EncodingException.message|{}message[0]
        final fun <get-message>(): kotlin/String // io.matthewnelson.encoding.core/EncodingException.message.<get-message>|<get-message>(){}[0]
}

open class io.matthewnelson.encoding.core/EncodingSizeException : io.matthewnelson.encoding.core/EncodingException { // io.matthewnelson.encoding.core/EncodingSizeException|null[0]
    constructor <init>(kotlin/String) // io.matthewnelson.encoding.core/EncodingSizeException.<init>|<init>(kotlin.String){}[0]
    constructor <init>(kotlin/String, kotlin/Throwable?) // io.matthewnelson.encoding.core/EncodingSizeException.<init>|<init>(kotlin.String;kotlin.Throwable?){}[0]
}

sealed class <#A: io.matthewnelson.encoding.core/EncoderDecoder.Config> io.matthewnelson.encoding.core/Decoder { // io.matthewnelson.encoding.core/Decoder|null[0]
    constructor <init>(#A) // io.matthewnelson.encoding.core/Decoder.<init>|<init>(1:0){}[0]

    final val config // io.matthewnelson.encoding.core/Decoder.config|{}config[0]
        final fun <get-config>(): #A // io.matthewnelson.encoding.core/Decoder.config.<get-config>|<get-config>(){}[0]

    abstract fun newDecoderFeedProtected(io.matthewnelson.encoding.core/Decoder.OutFeed): io.matthewnelson.encoding.core/Decoder.Feed<#A> // io.matthewnelson.encoding.core/Decoder.newDecoderFeedProtected|newDecoderFeedProtected(io.matthewnelson.encoding.core.Decoder.OutFeed){}[0]
    final fun newDecoderFeed(io.matthewnelson.encoding.core/Decoder.OutFeed): io.matthewnelson.encoding.core/Decoder.Feed<#A> // io.matthewnelson.encoding.core/Decoder.newDecoderFeed|newDecoderFeed(io.matthewnelson.encoding.core.Decoder.OutFeed){}[0]

    abstract fun interface OutFeed { // io.matthewnelson.encoding.core/Decoder.OutFeed|null[0]
        abstract fun output(kotlin/Byte) // io.matthewnelson.encoding.core/Decoder.OutFeed.output|output(kotlin.Byte){}[0]
    }

    abstract inner class Feed : io.matthewnelson.encoding.core/EncoderDecoder.Feed<#A> { // io.matthewnelson.encoding.core/Decoder.Feed|null[0]
        constructor <init>() // io.matthewnelson.encoding.core/Decoder.Feed.<init>|<init>(){}[0]

        abstract fun consumeProtected(kotlin/Char) // io.matthewnelson.encoding.core/Decoder.Feed.consumeProtected|consumeProtected(kotlin.Char){}[0]
        final fun close() // io.matthewnelson.encoding.core/Decoder.Feed.close|close(){}[0]
        final fun consume(kotlin/Char) // io.matthewnelson.encoding.core/Decoder.Feed.consume|consume(kotlin.Char){}[0]
        final fun flush() // io.matthewnelson.encoding.core/Decoder.Feed.flush|flush(){}[0]
        final fun isClosed(): kotlin/Boolean // io.matthewnelson.encoding.core/Decoder.Feed.isClosed|isClosed(){}[0]
        final fun toString(): kotlin/String // io.matthewnelson.encoding.core/Decoder.Feed.toString|toString(){}[0]
    }

    final object Companion { // io.matthewnelson.encoding.core/Decoder.Companion|null[0]
        final fun (kotlin/ByteArray).decodeToByteArray(io.matthewnelson.encoding.core/Decoder<*>): kotlin/ByteArray // io.matthewnelson.encoding.core/Decoder.Companion.decodeToByteArray|decodeToByteArray@kotlin.ByteArray(io.matthewnelson.encoding.core.Decoder<*>){}[0]
        final fun (kotlin/ByteArray).decodeToByteArrayOrNull(io.matthewnelson.encoding.core/Decoder<*>): kotlin/ByteArray? // io.matthewnelson.encoding.core/Decoder.Companion.decodeToByteArrayOrNull|decodeToByteArrayOrNull@kotlin.ByteArray(io.matthewnelson.encoding.core.Decoder<*>){}[0]
        final fun (kotlin/CharArray).decodeToByteArray(io.matthewnelson.encoding.core/Decoder<*>): kotlin/ByteArray // io.matthewnelson.encoding.core/Decoder.Companion.decodeToByteArray|decodeToByteArray@kotlin.CharArray(io.matthewnelson.encoding.core.Decoder<*>){}[0]
        final fun (kotlin/CharArray).decodeToByteArrayOrNull(io.matthewnelson.encoding.core/Decoder<*>): kotlin/ByteArray? // io.matthewnelson.encoding.core/Decoder.Companion.decodeToByteArrayOrNull|decodeToByteArrayOrNull@kotlin.CharArray(io.matthewnelson.encoding.core.Decoder<*>){}[0]
        final fun (kotlin/CharSequence).decodeToByteArray(io.matthewnelson.encoding.core/Decoder<*>): kotlin/ByteArray // io.matthewnelson.encoding.core/Decoder.Companion.decodeToByteArray|decodeToByteArray@kotlin.CharSequence(io.matthewnelson.encoding.core.Decoder<*>){}[0]
        final fun (kotlin/CharSequence).decodeToByteArrayOrNull(io.matthewnelson.encoding.core/Decoder<*>): kotlin/ByteArray? // io.matthewnelson.encoding.core/Decoder.Companion.decodeToByteArrayOrNull|decodeToByteArrayOrNull@kotlin.CharSequence(io.matthewnelson.encoding.core.Decoder<*>){}[0]
    }
}

sealed class <#A: io.matthewnelson.encoding.core/EncoderDecoder.Config> io.matthewnelson.encoding.core/Encoder : io.matthewnelson.encoding.core/Decoder<#A> { // io.matthewnelson.encoding.core/Encoder|null[0]
    constructor <init>(#A) // io.matthewnelson.encoding.core/Encoder.<init>|<init>(1:0){}[0]

    abstract fun newEncoderFeedProtected(io.matthewnelson.encoding.core/Encoder.OutFeed): io.matthewnelson.encoding.core/Encoder.Feed<#A> // io.matthewnelson.encoding.core/Encoder.newEncoderFeedProtected|newEncoderFeedProtected(io.matthewnelson.encoding.core.Encoder.OutFeed){}[0]
    final fun newEncoderFeed(io.matthewnelson.encoding.core/Encoder.OutFeed): io.matthewnelson.encoding.core/Encoder.Feed<#A> // io.matthewnelson.encoding.core/Encoder.newEncoderFeed|newEncoderFeed(io.matthewnelson.encoding.core.Encoder.OutFeed){}[0]

    abstract fun interface OutFeed { // io.matthewnelson.encoding.core/Encoder.OutFeed|null[0]
        abstract fun output(kotlin/Char) // io.matthewnelson.encoding.core/Encoder.OutFeed.output|output(kotlin.Char){}[0]
    }

    abstract inner class Feed : io.matthewnelson.encoding.core/EncoderDecoder.Feed<#A> { // io.matthewnelson.encoding.core/Encoder.Feed|null[0]
        constructor <init>() // io.matthewnelson.encoding.core/Encoder.Feed.<init>|<init>(){}[0]

        abstract fun consumeProtected(kotlin/Byte) // io.matthewnelson.encoding.core/Encoder.Feed.consumeProtected|consumeProtected(kotlin.Byte){}[0]
        abstract fun doFinalProtected() // io.matthewnelson.encoding.core/Encoder.Feed.doFinalProtected|doFinalProtected(){}[0]
        final fun close() // io.matthewnelson.encoding.core/Encoder.Feed.close|close(){}[0]
        final fun consume(kotlin/Byte) // io.matthewnelson.encoding.core/Encoder.Feed.consume|consume(kotlin.Byte){}[0]
        final fun flush() // io.matthewnelson.encoding.core/Encoder.Feed.flush|flush(){}[0]
        final fun isClosed(): kotlin/Boolean // io.matthewnelson.encoding.core/Encoder.Feed.isClosed|isClosed(){}[0]
        final fun toString(): kotlin/String // io.matthewnelson.encoding.core/Encoder.Feed.toString|toString(){}[0]
    }

    final object Companion { // io.matthewnelson.encoding.core/Encoder.Companion|null[0]
        final fun (kotlin/ByteArray).encodeToByteArray(io.matthewnelson.encoding.core/Encoder<*>): kotlin/ByteArray // io.matthewnelson.encoding.core/Encoder.Companion.encodeToByteArray|encodeToByteArray@kotlin.ByteArray(io.matthewnelson.encoding.core.Encoder<*>){}[0]
        final fun (kotlin/ByteArray).encodeToCharArray(io.matthewnelson.encoding.core/Encoder<*>): kotlin/CharArray // io.matthewnelson.encoding.core/Encoder.Companion.encodeToCharArray|encodeToCharArray@kotlin.ByteArray(io.matthewnelson.encoding.core.Encoder<*>){}[0]
        final fun (kotlin/ByteArray).encodeToString(io.matthewnelson.encoding.core/Encoder<*>): kotlin/String // io.matthewnelson.encoding.core/Encoder.Companion.encodeToString|encodeToString@kotlin.ByteArray(io.matthewnelson.encoding.core.Encoder<*>){}[0]
    }
}

final inline fun <#A: io.matthewnelson.encoding.core/EncoderDecoder.Config, #B: io.matthewnelson.encoding.core/EncoderDecoder.Feed<#A>?, #C: kotlin/Any?> (#B).io.matthewnelson.encoding.core/use(kotlin/Function1<#B, #C>): #C // io.matthewnelson.encoding.core/use|use@0:1(kotlin.Function1<0:1,0:2>){0§<io.matthewnelson.encoding.core.EncoderDecoder.Config>;1§<io.matthewnelson.encoding.core.EncoderDecoder.Feed<0:0>?>;2§<kotlin.Any?>}[0]
